import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";
import dotenv from 'dotenv';
import express from 'express';
import cors from 'cors';
import mongoose from 'mongoose';
import cookieParser from 'cookie-parser';
import { createServer } from 'node:http';
import events, { EventEmitter } from 'events';
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';
import http from 'http';
import winston from 'winston';
import expressWinston from 'express-winston';
import helmet from 'helmet';

// Import centralized logging configuration
import { mainLogger, correlationMiddleware, httpLogger, Log } from './config/logger';

// Import services and configurations
// import { LiveOrderMonitor } from './services/LiveOrderMonitor';
import { initSocketIO, closeSocketIO } from './socketio';
// Remove problematic imports
// import { ApiRoutes } from './routes/api.routes';
// import { AuthRoutes } from './routes/auth.routes';
// import { AdminRoutes } from './routes/admin.routes';
import { seedRolesAndPermissions } from '../services/auth-service/src/seed';
import { initializePassport } from '../services/auth-service/src/config/passport';
// Import order service
import { initializeOrderService, shutdownOrderService } from '../services/order-service/src/server';

// Load environment variables first
dotenv.config();

// Initialize Sentry BEFORE importing other modules
Sentry.init({
  dsn: process.env.SENTRY_DSN || "https://f3805f9a5ff5cca9081bcd847754d46a@o4509519163686912.ingest.de.sentry.io/4509539014803536",
  integrations: [
    nodeProfilingIntegration(),
  ],
  // Performance Monitoring
  tracesSampleRate: 1.0,
  // Release Health
  profilesSampleRate: 1.0,
  environment: process.env.NODE_ENV || 'development',
});

// Log application startup
Log.info('Starting INSEAT Backend application', {
  nodeVersion: process.version,
  nodeEnv: process.env.NODE_ENV,
  pid: process.pid
});

// Increase max listeners to avoid memory leak warning
events.defaultMaxListeners = 20;

// Initialize the app
const app = express();
const server = createServer(app);
const eventEmitter = new EventEmitter();

// Initialize a single Socket.IO server using our singleton approach
const io = initSocketIO(server);

// Instead of creating a separate WebSocketManager instance, we'll use the Socket.IO instance
// Export io for external use through getSocketIO() function
export { getSocketIO } from './socketio';

// Export app and server but not io (use getSocketIO() instead)
export { app, server };

// Import Stripe for webhook handling
import Stripe from 'stripe';

// Now we can safely import services
import apiRoutes, { initializeAIService, initializeAnalyticsService, initializeInventoryService } from '../services/index';
import adminRoutes from '../services/auth-service/src/routes/adminRoutes';
import authRoutes from '../services/auth-service/src/routes/authRoutes';
import rbacRoutes from '../services/auth-service/src/routes/rbacRoutes';
import systemAdminRoutes from '../services/auth-service/src/routes/systemAdminRoutes';
import passwordSetupRoutes from '../services/auth-service/src/routes/passwordSetupRoutes';
import customerRoutes from '../services/auth-service/src/routes/customerRoutes';
import businessAdminRoutes from '../services/auth-service/src/routes/businessAdminRoutes';
import permissionMatrixRoutes from '../services/auth-service/src/routes/permissionMatrixRoutes';
// Import restaurant service routes
import adminPromotionRoutes from '../services/restaurant-service/src/routes/adminPromotion.routes';
import restaurantRoutes from '../services/restaurant-service/src/routes/restaurant.routes';
import publicMenuRoutes from '../services/restaurant-service/src/routes/publicMenu.routes';
import businessRoutes from '../services/restaurant-service/src/routes/business.routes';
import kitchenRoutes from '../services/auth-service/src/routes/kitchenRoutes';
import cashierRoutes from '../services/auth-service/src/routes/cashierRoutes';
import scheduleRoutes from '../services/auth-service/src/routes/scheduleRoutes';

// Configure middleware
// Get allowed origins from environment variable
const allowedOriginsStr = process.env.CORS_ORIGINS || process.env.ALLOWED_ORIGINS || 'https://cms.inseat.achievengine.com,https://menu.inseat.achievengine.com,http://localhost:3000,http://localhost:5173,http://localhost:5174,http://localhost:8080,http://localhost:8081';
Log.info('CORS configuration loaded', { allowedOrigins: allowedOriginsStr });
const allowedOrigins = allowedOriginsStr.split(',').map(origin => origin.trim());

// Make sure localhost:5173 and 5174 are included (admin and menu interfaces)
if (!allowedOrigins.includes('http://localhost:5173')) {
  allowedOrigins.push('http://localhost:5173');
}
if (!allowedOrigins.includes('http://localhost:5174')) {
  allowedOrigins.push('http://localhost:5174');
}

// Check if production URLs are included
if (!allowedOrigins.includes('https://cms.inseat.achievengine.com')) {
  allowedOrigins.push('https://cms.inseat.achievengine.com');
}
if (!allowedOrigins.includes('https://menu.inseat.achievengine.com')) {
  allowedOrigins.push('https://menu.inseat.achievengine.com');
}

// Log CORS configuration
Log.info('CORS Configuration complete', { finalAllowedOrigins: allowedOrigins });

// Add specific origins to ensure they're always included
if (!allowedOrigins.includes('http://localhost:5175')) {
  allowedOrigins.push('http://localhost:5175');
}

// Log final allowed origins
Log.info('Final CORS origins configured', { allowedOrigins });

// Add correlation ID middleware early
app.use(correlationMiddleware);

// Enhanced CORS configuration for better compatibility
app.use(cors({
  origin: function(origin, callback) {
    // Debug incoming origin
    Log.debug('CORS origin check', { origin: origin || 'No origin' }); 
    
    // Allow requests with no origin (like mobile apps, curl, postman)
    if (!origin) {
      Log.debug('No origin header, allowing request');
      return callback(null, true);
    }
    
    // Allow all origins if wildcard is present
    if (allowedOrigins.includes('*')) {
      Log.debug('Wildcard origin allowed, accepting all origins');
      return callback(null, true);
    }
    
    // Special case for localhost:5173 (admin interface)
    if (origin === 'http://localhost:5173' || origin === 'http://localhost:5175') {
      Log.debug('Explicitly allowing admin interface origin', { origin });
      return callback(null, true);
    }
    
    // Check if origin is in allowed list
    if (allowedOrigins.includes(origin)) {
      Log.debug('Origin in allowed list', { origin });
      return callback(null, true);
    } else {
      Log.warn('CORS origin not allowed', { origin, allowedOrigins });
      return callback(new Error(`Origin ${origin} not allowed by CORS`));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'],
  allowedHeaders: [
    'Origin',
    'X-Requested-With', 
    'Content-Type',
    'Accept',
    'Authorization',
    'Cache-Control',
    'cache-control',
    'X-CSRF-Token',
    'X-Auth-Token',
    'Access-Control-Allow-Headers',
    'Access-Control-Allow-Origin',
    'Access-Control-Allow-Methods',
    'X-Elevenlabs-Api-Key'  // Add ElevenLabs API key header
  ],
  exposedHeaders: ['Set-Cookie', 'Access-Control-Allow-Origin', 'Access-Control-Allow-Headers'],
  preflightContinue: false,
  optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204
}));

// Add a global OPTIONS handler for any route that doesn't have one
app.options('*', (req, res) => {
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control, X-CSRF-Token, X-Auth-Token, X-Elevenlabs-Api-Key');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.sendStatus(200);
});

// IMPORTANT: Special handling for Stripe webhooks - must come BEFORE the regular JSON body parser
// Initialize Stripe with the secret key
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {
  apiVersion: '2023-10-16',
});

// Create a raw body parser middleware for Stripe webhooks
const rawBodyParser = express.raw({ type: 'application/json' });

// Create a middleware to preserve the raw body in the request object
const webhookMiddleware = (req: any, res: any, next: any) => {
  if (req.originalUrl.includes('/webhook')) {
    console.log('üì¶ Preserving raw body for webhook verification');
    // Save the raw body buffer before Express processes it
    if (Buffer.isBuffer(req.body)) {
      console.log('‚úÖ Raw body is a Buffer - ideal for signature verification');
      req.rawBody = req.body;
      
      // For logging only - don't use this parsed JSON for signature verification
      try {
        const jsonBody = JSON.parse(req.body.toString('utf8'));
        console.log(`üìä Webhook event type: ${jsonBody.type || 'unknown'}`);
      } catch (err) {
        console.log('‚ö†Ô∏è Could not parse webhook body to JSON for logging');
      }
    } else {
      console.log(`‚ö†Ô∏è Raw body is not a Buffer but ${typeof req.body}`);
    }
  }
  next();
};

// Register webhook routes with the raw body parser BEFORE the json parser
app.post('/api/payments/webhook', rawBodyParser, webhookMiddleware);
app.post('/payments/webhook', rawBodyParser, webhookMiddleware);
app.post('/api/webhook', rawBodyParser, webhookMiddleware);
app.post('/webhook', rawBodyParser, webhookMiddleware);
console.log('Stripe webhook handlers configured with proper raw body preservation');

// Regular body parsers for all other routes
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());
app.disable('x-powered-by');

// Set up security headers
app.use(helmet());

// Add HTTP request logging middleware
app.use(httpLogger);

// Force development mode for debugging
process.env.NODE_ENV = 'development';

// Enable debug logging
const DEBUG = true;

// Add debug middleware
app.use((req: any, res: any, next: any) => {
  if (DEBUG) {
    const oldJson = res.json;
    res.json = function(data) {
      Log.debug('Response data sent', { 
        url: req.url, 
        method: req.method, 
        statusCode: res.statusCode,
        correlationId: req.correlationId 
      });
      return oldJson.call(this, data);
    };
  }
  next();
});

// Add debug logging for Passport initialization
Log.info('Initializing Passport authentication', {
  googleClientId: process.env.GOOGLE_CLIENT_ID ? 'SET' : 'NOT SET',
  googleCallbackUrl: process.env.GOOGLE_CALLBACK_URL ? 'SET' : 'NOT SET'
});

// Initialize passport with the function instead of using the import directly
const passport = initializePassport();
app.use(passport.initialize());

// Connect to MongoDB with enhanced connection options
const connectWithRetry = async (retryCount = 0, maxRetries = 5) => {
  const mongoUrl = process.env.MONGO_URL || 'mongodb+srv://abenezer:YXVC8lBaPIcb2o3s@cluster0.oljifwd.mongodb.net/inseat?retryWrites=true&w=majority&appName=Cluster0';
  
  Log.info('MongoDB connection attempt', { 
    url: mongoUrl.replace(/\/\/.*@/, '//*****@'), // Hide credentials
    attempt: retryCount + 1,
    maxRetries,
    currentState: mongoose.connection.readyState,
    useEnvUrl: !!process.env.MONGO_URL
  });
  
  // Enable debug mode for Mongoose in non-production environments
  mongoose.set('debug', process.env.NODE_ENV !== 'production');
  
  const mongooseOptions: mongoose.ConnectOptions = {
    serverSelectionTimeoutMS: 60000,      // 60 seconds
    socketTimeoutMS: 45000,               // 45 seconds
    connectTimeoutMS: 60000,              // 60 seconds
    maxPoolSize: 50,                      // Increase pool size
    minPoolSize: 10,                      // Increase minimum pool size
    heartbeatFrequencyMS: 10000,          // Keep as is
    retryWrites: true,                    // Enable automatic retry of write operations
    retryReads: true,                     // Enable automatic retry of read operations
    autoIndex: true,                      // Build indexes
    bufferCommands: true,                 // Enable command buffering
    maxIdleTimeMS: 45000,                 // How long a connection can be idle before closing
    family: 4,                            // Use IPv4, skip trying IPv6
    // Removed monitorCommands as it's not in ConnectOptions type
    writeConcern: {
      w: 'majority',
      wtimeoutMS: 30000                   // Changed wtimeout to wtimeoutMS
    },
    readPreference: 'primary'             // Remove readConcern as it's causing type issues
  };
  
  try {
    Log.info('Attempting MongoDB connection...');
    
    // Remove any existing listeners to prevent duplicates
    mongoose.connection.removeAllListeners();
    
    // Add connection event listeners
    mongoose.connection.on('connecting', () => {
      Log.info('Establishing connection to MongoDB...');
    });

    mongoose.connection.on('connected', () => {
      Log.info('Successfully connected to MongoDB');
    });

    mongoose.connection.once('ready', () => {
      Log.info('MongoDB connection is ready for use');
    });

    mongoose.connection.on('error', (err) => {
      Log.error('MongoDB connection error', { error: err.message, stack: err.stack });
      // Don't exit process here, let the retry logic handle it
    });

    mongoose.connection.on('disconnected', () => {
      Log.warn('Disconnected from MongoDB');
    });
    
    mongoose.connection.on('reconnected', () => {
      Log.info('Reconnected to MongoDB');
    });
    
    await mongoose.connect(mongoUrl, mongooseOptions);
    Log.info('MongoDB connection established successfully');
    
    // Wait for indexes to be built
    Log.info('Waiting for database initialization...');
    await Promise.all([
      // Safely handle the db property which might be undefined
      (mongoose.connection.readyState === 1 && mongoose.connection.db) 
        ? Promise.resolve(mongoose.connection.db.command({ ping: 1 })) 
        : Promise.resolve(null),
      new Promise(resolve => setTimeout(resolve, 2000)) // Give extra time for indexes
    ]);
    Log.info('Database ready for operations');
    
    // Seed the database with initial roles and permissions for auth service
    try {
      Log.info('Starting roles and permissions seeding...');
      // Uncomment and run the seeding function
      const seedResult = await seedRolesAndPermissions();
      Log.info('Roles and permissions seeding completed successfully', { seedResult });
    } catch (error) {
      Log.error('Error seeding roles and permissions', { 
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      // Continue execution despite seeding errors - existing data may be sufficient
      Log.info('Continuing startup despite seeding issues');
    }

    // Initialize order service after MongoDB connection is established
    try {
      initializeOrderService(app, io);
      Log.info('Order service initialized successfully');
    } catch (error) {
      Log.error('Failed to initialize order service', { 
        error: error instanceof Error ? error.message : String(error)
      });
    }

    // Initialize AI service after MongoDB connection is established
    try {
      await initializeAIService();
      Log.info('AI service initialized successfully');
    } catch (error) {
      Log.error('Failed to initialize AI service', { 
        error: error instanceof Error ? error.message : String(error)
      });
      Log.warn('AI service will have limited functionality');
    }

    // Initialize Analytics service
    try {
      initializeAnalyticsService();
      Log.info('Analytics service initialized successfully');
    } catch (error) {
      Log.error('Failed to initialize Analytics service', { 
        error: error instanceof Error ? error.message : String(error)
      });
      Log.warn('Analytics service will have limited functionality');
    }

    // Initialize inventory service after MongoDB connection is established
    try {
      initializeInventoryService(app, io);
      Log.info('Inventory service initialized successfully');
    } catch (error) {
      Log.error('Failed to initialize inventory service', { 
        error: error instanceof Error ? error.message : String(error)
      });
      Log.warn('Inventory service will have limited functionality');
    }
    
    return true;
  } catch (err) {
    Log.error('MongoDB connection failed', { 
      attempt: retryCount + 1,
      maxRetries,
      error: err instanceof Error ? err.message : String(err),
      stack: err instanceof Error ? err.stack : undefined
    });
    if (retryCount < maxRetries) {
      Log.info('Retrying MongoDB connection in 5 seconds...', { nextAttempt: retryCount + 2 });
      await new Promise(resolve => setTimeout(resolve, 5000));
      return connectWithRetry(retryCount + 1, maxRetries);
    } else {
      Log.error('Max MongoDB connection retries reached. Exiting.');
      process.exit(1);
    }
  }
};

// Modify the server startup sequence to wait for MongoDB
const startServer = async () => {
  try {
    // Wait for MongoDB to be fully connected and initialized
    await connectWithRetry();
    
    // Verify connection state before starting server
    const connectionState = mongoose.connection.readyState;
    Log.info('MongoDB connection verified before server start', { 
      connectionState,
      stateDescription: ['disconnected', 'connected', 'connecting', 'disconnecting'][connectionState]
    });
    
    if (connectionState !== 1) {
      Log.error('Cannot start server: MongoDB not connected', { connectionState });
      process.exit(1);
    }
    
    // Start server only after MongoDB is ready
    const PORT = process.env.PORT || 3001;
    server.listen(PORT, () => {
      Log.info('INSEAT Backend server started successfully', {
        port: PORT,
        corsOrigins: process.env.CORS_ORIGINS || 'default CORS origins',
        environment: process.env.NODE_ENV || 'development',
        apiDocsUrl: `http://localhost:${PORT}/api-docs`
      });
    });
  } catch (error) {
    Log.error('Failed to start server', { 
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    });
    process.exit(1);
  }
};

// Start the server with proper initialization sequence
startServer();

// Initialize LiveOrderMonitor
// LiveOrderMonitor.getInstance().start();

// Database connection check middleware with updated connection handling
const checkDatabaseConnection = async (req: any, res: any, next: any) => {
  try {
    // First check current connection
    const state = mongoose.connection.readyState;
    Log.debug('Database connection check', {
      method: req.method,
      path: req.path,
      currentState: state,
      correlationId: req.correlationId
    });
    
    // If disconnected, try to reconnect
    if (state === 0) {
      Log.warn('No database connection, attempting to reconnect...');
      await connectWithRetry();
    }
    
    // Check state again after potential reconnection
    const newState = mongoose.connection.readyState;
    Log.debug('Database connection state after check', { 
      previousState: state,
      newState,
      correlationId: req.correlationId 
    });
    
    if (newState === 1) {
      return next();
    }
    
    Log.error('Database connection not ready', { state: newState, correlationId: req.correlationId });
    return res.status(503).json({
      message: "Service temporarily unavailable",
      details: `Database connection not ready (state: ${newState})`
    });
  } catch (error) {
    Log.error('Database connection check error', { 
      error: error instanceof Error ? error.message : String(error),
      correlationId: req.correlationId
    });
    return res.status(503).json({
      message: "Service temporarily unavailable", 
      details: "Database connection error"
    });
  }
};

// Add request logging middleware for auth-related routes
const authRequestLogger = (req: any, res: any, next: any) => {
  Log.info('Auth request received', {
    method: req.method,
    path: req.path,
    hasBody: !!req.body && Object.keys(req.body).length > 0,
    hasPassword: !!(req.body && req.body.password),
    hasCookies: !!req.cookies,
    hasAccessToken: !!(req.cookies && req.cookies.access_token),
    hasRefreshToken: !!(req.cookies && req.cookies.refresh_token),
    correlationId: req.correlationId
  });
  next();
};

// Reorder route mounting to ensure proper middleware application

// First apply auth request logging middleware
app.use('/api/auth', authRequestLogger);

// Note: Direct routes were causing TypeScript errors and have been removed
// Instead, we've updated the payment routes in services/payment-service/routes/paymentRoutes.ts
// to not require authentication for session status endpoints

// Then apply database connection check middleware
app.use('/api/auth', checkDatabaseConnection);
app.use('/api/rbac', checkDatabaseConnection);
app.use('/api/admin', checkDatabaseConnection);
app.use('/api/system-admin', checkDatabaseConnection);
app.use('/api/password', checkDatabaseConnection);
app.use('/api/business-admin', checkDatabaseConnection);
app.use('/api/permission-matrix', checkDatabaseConnection);

// INVENTORY ROUTES - HIGHEST PRIORITY
app.get('/api/inventory/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    service: 'inventory-direct', 
    timestamp: new Date().toISOString()
  });
});

app.get('/api/inventory/test', (req, res) => {
  res.json({ success: true, message: 'Inventory test endpoint working' });
});

app.get('/api/inventory/items', async (req, res) => {
  try {
    const { restaurantId } = req.query;
    if (!restaurantId) {
      return res.status(400).json({ error: 'restaurantId required' });
    }
    
    const mongoose = require('mongoose');
    const db = mongoose.connection.db;
    const items = await db.collection('inventoryitems').find({
      restaurantId: new mongoose.Types.ObjectId(restaurantId as string),
      isActive: true
    }).toArray();
    
    res.json({ success: true, data: items });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ success: false, error: (error as Error).message });
  }
});

app.get('/api/inventory/recipes', async (req, res) => {
  try {
    const { restaurantId } = req.query;
    if (!restaurantId) {
      return res.status(400).json({ error: 'restaurantId required' });
    }
    
    const mongoose = require('mongoose');
    const db = mongoose.connection.db;
    const recipes = await db.collection('recipes').find({
      restaurantId: new mongoose.Types.ObjectId(restaurantId as string),
      isActive: true
    }).toArray();
    
    res.json({ success: true, data: recipes });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ success: false, error: (error as Error).message });
  }
});

// Mount auth and admin routes BEFORE general API routes
app.use('/api/auth', authRoutes as any);
app.use('/api/rbac', rbacRoutes as any);
app.use('/api/admin', adminRoutes as any);
app.use('/api/system-admin', systemAdminRoutes as any);
app.use('/api/password', passwordSetupRoutes as any);
app.use('/api/customer', customerRoutes as any);
app.use('/api/business-admin', businessAdminRoutes as any);
app.use('/api/permission-matrix', permissionMatrixRoutes as any);

// Mount restaurant service routes
app.use('/api/admin-promotions', adminPromotionRoutes as any);
app.use('/api/restaurants', restaurantRoutes as any);
app.use('/api/restaurant-service', businessRoutes as any);
app.use('/api/public/menu', publicMenuRoutes as any);

// Mount kitchen, cashier, and schedule routes
app.use('/api/kitchens', kitchenRoutes as any);
app.use('/api/cashiers', cashierRoutes as any);
app.use('/api/schedules', scheduleRoutes as any);

// Duplicate inventory routes removed - moved to top of file for priority

// Removed conflicting inventory router that was overriding specific routes

// COMPREHENSIVE INVENTORY MANAGEMENT ROUTES - UPDATED - DIRECT MOUNTING
try {
  const mongoose = require('mongoose');
  const { Schema } = mongoose;
  
  // Recipe Schema - matches the existing data structure
  const RecipeSchema = new Schema({
    name: { type: String, required: true },
    description: String,
    category: { type: String, default: 'Main Course' },
    servingSize: { type: Number, default: 1 },
    prepTime: { type: Number, default: 0 }, // minutes
    cookTime: { type: Number, default: 0 }, // minutes
    difficulty: { type: String, enum: ['Easy', 'Medium', 'Hard'], default: 'Medium' },
    instructions: [String],
    ingredients: [{
      inventoryItemId: { type: mongoose.Schema.Types.ObjectId, ref: 'InventoryItem' },
      quantity: { type: Number, required: true },
      unit: { type: String, required: true },
      notes: String
    }],
    expectedYield: {
      quantity: { type: Number, default: 1 },
      unit: { type: String, default: 'portions' }
    },
    costPerPortion: { type: Number, default: 0 },
    totalCost: { type: Number, default: 0 },
    restaurantId: { type: mongoose.Schema.Types.ObjectId, required: true, index: true },
    isActive: { type: Boolean, default: true },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
  });
  
  // Enhanced Inventory Item Schema
  const InventoryItemSchema = new Schema({
    name: { type: String, required: true },
    description: String,
    category: String,
    subcategory: String,
    sku: String,
    unit: { type: String, required: true },
    currentStock: { type: Number, default: 0 },
    minimumStock: { type: Number, default: 5 },
    maximumStock: { type: Number, default: 100 },
    reorderPoint: { type: Number, default: 10 },
    averageCost: { type: Number, default: 0 },
    lastCost: { type: Number, default: 0 },
    location: String,
    storageRequirements: String,
    isPerishable: { type: Boolean, default: false },
    shelfLife: Number, // days
    allergens: [String],
    supplierId: { type: mongoose.Schema.Types.ObjectId },
    restaurantId: { type: mongoose.Schema.Types.ObjectId, required: true, index: true },
    isActive: { type: Boolean, default: true },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
  });
  
  // Get or create models (handle case where they might already exist)
  let InventoryItemModel, RecipeModel;
  try {
    InventoryItemModel = mongoose.model('InventoryItem');
  } catch {
    InventoryItemModel = mongoose.model('InventoryItem', InventoryItemSchema);
  }
  try {
    RecipeModel = mongoose.model('Recipe');
  } catch {
    RecipeModel = mongoose.model('Recipe', RecipeSchema);
  }
  
  // === INVENTORY ITEMS ENDPOINTS ===
  
  // GET /api/inventory/items - Get all inventory items
  app.get('/api/inventory/items', async (req, res) => {
    try {
      const { restaurantId, category, lowStock } = req.query;
      if (!restaurantId) {
        return res.status(400).json({ error: 'restaurantId query parameter is required' });
      }
      
      let query: any = { restaurantId, isActive: true };
      if (category) query.category = category;
      
      const items = await InventoryItemModel.find(query).sort({ name: 1 });
      
      // Filter for low stock if requested
      let filteredItems = items;
      if (lowStock === 'true') {
        filteredItems = items.filter(item => item.currentStock <= item.reorderPoint);
      }
      
      res.json({ success: true, data: filteredItems });
    } catch (error) {
      console.error('Error getting inventory items:', error);
      res.status(500).json({ success: false, error: 'Failed to get inventory items' });
    }
  });
  
  // POST /api/inventory/items - Create inventory item
  app.post('/api/inventory/items', async (req, res) => {
    try {
      const { restaurantId } = req.query;
      if (!restaurantId) {
        return res.status(400).json({ error: 'restaurantId query parameter is required' });
      }
      
      const itemData = { ...req.body, restaurantId };
      const item = new InventoryItemModel(itemData);
      await item.save();
      
      res.status(201).json({ success: true, data: item });
    } catch (error) {
      console.error('Error creating inventory item:', error);
      res.status(500).json({ success: false, error: 'Failed to create inventory item' });
    }
  });
  
  // GET /api/inventory/items/:id - Get inventory item by ID
  app.get('/api/inventory/items/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const { restaurantId } = req.query;
      
      if (!restaurantId) {
        return res.status(400).json({ error: 'restaurantId query parameter is required' });
      }
      
      const item = await InventoryItemModel.findOne({ _id: id, restaurantId, isActive: true });
      if (!item) {
        return res.status(404).json({ success: false, error: 'Inventory item not found' });
      }
      
      res.json({ success: true, data: item });
    } catch (error) {
      console.error('Error getting inventory item:', error);
      res.status(500).json({ success: false, error: 'Failed to get inventory item' });
    }
  });
  
  // === RECIPE ENDPOINTS ===
  
  // GET /api/inventory/recipes - Get all recipes
  app.get('/api/inventory/recipes', async (req, res) => {
    try {
      const { restaurantId, category, menuItemId } = req.query;
      if (!restaurantId) {
        return res.status(400).json({ error: 'restaurantId query parameter is required' });
      }
      
      let query: any = { restaurantId, isActive: true };
      if (category) query.category = category;
      if (menuItemId) query.menuItemId = menuItemId;
      
      const recipes = await RecipeModel.find(query)
        .populate('ingredients.inventoryItemId')
        .sort({ name: 1 });
      
      res.json({ 
        success: true, 
        data: recipes,
        pagination: {
          currentPage: 1,
          totalPages: 1,
          totalCount: recipes.length,
          hasNext: false,
          hasPrevious: false
        }
      });
    } catch (error) {
      console.error('Error getting recipes:', error);
      res.status(500).json({ success: false, error: 'Failed to get recipes' });
    }
  });
  
  // POST /api/inventory/recipes - Create recipe
  app.post('/api/inventory/recipes', async (req, res) => {
    try {
      const { restaurantId } = req.query;
      if (!restaurantId) {
        return res.status(400).json({ error: 'restaurantId query parameter is required' });
      }
      
      const recipeData = { ...req.body, restaurantId };
      const recipe = new RecipeModel(recipeData);
      await recipe.save();
      
      const populatedRecipe = await RecipeModel.findById(recipe._id)
        .populate('ingredients.inventoryItemId');
      
      res.status(201).json({ success: true, data: populatedRecipe });
    } catch (error) {
      console.error('Error creating recipe:', error);
      res.status(500).json({ success: false, error: 'Failed to create recipe' });
    }
  });
  
  // === ANALYTICS ENDPOINTS ===
  
  // GET /api/inventory/analytics/inventory/value - Get inventory valuation
  app.get('/api/inventory/analytics/inventory/value', async (req, res) => {
    try {
      const { restaurantId } = req.query;
      if (!restaurantId) {
        return res.status(400).json({ error: 'restaurantId query parameter is required' });
      }
      
      const items = await InventoryItemModel.find({ restaurantId, isActive: true });
      
      const totalValue = items.reduce((sum, item) => {
        return sum + (item.currentStock * item.averageCost);
      }, 0);
      
      // Group by category
      const categoryBreakdown = {};
      items.forEach(item => {
        const category = item.category || 'Uncategorized';
        if (!categoryBreakdown[category]) {
          categoryBreakdown[category] = { value: 0, items: 0 };
        }
        categoryBreakdown[category].value += item.currentStock * item.averageCost;
        categoryBreakdown[category].items += 1;
      });
      
      const categoryArray = Object.entries(categoryBreakdown).map(([category, data]: [string, any]) => ({
        category,
        value: data.value,
        percentage: totalValue > 0 ? (data.value / totalValue * 100) : 0,
        itemCount: data.items
      }));
      
      res.json({ 
        success: true, 
        data: {
          totalValue: parseFloat(totalValue.toFixed(2)),
          categoryBreakdown: categoryArray,
          itemCount: items.length,
          timestamp: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Error getting inventory value:', error);
      res.status(500).json({ success: false, error: 'Failed to get inventory value' });
    }
  });
  
  // Health check endpoints
  app.get('/api/inventory/health', (req, res) => {
    res.json({ 
      status: 'healthy', 
      service: 'inventory-comprehensive', 
      timestamp: new Date().toISOString(),
      endpoints: [
        'GET /api/inventory/items',
        'POST /api/inventory/items',
        'GET /api/inventory/items/:id',
        'GET /api/inventory/recipes',
        'POST /api/inventory/recipes',
        'GET /api/inventory/analytics/inventory/value'
      ]
    });
  });
  
  app.get('/api/health', (req, res) => {
    res.json({ status: 'ok', service: 'inseat-backend-with-inventory' });
  });
  
  Log.info('‚úÖ Comprehensive inventory & recipe system mounted successfully');
} catch (error) {
  Log.error('‚ùå Failed to mount comprehensive inventory system', { error });
}

// Test endpoint to verify if routes can be added
app.get('/api/test-inventory', (req, res) => {
  res.json({ message: 'Test inventory endpoint working', timestamp: new Date().toISOString() });
});

// Finally mount all other API routes
app.use('/api', apiRoutes);

// Direct table verify endpoint
import Table from '../services/restaurant-service/src/models/Table';

// Define interfaces for the table verification endpoint
interface TableData {
  _id: string;
  number: string;
  capacity: number;
  isOccupied: boolean;
  isActive: boolean;
}

interface VenueData {
  _id: string;
  name: string;
  description: string;
  restaurantId: string;
}

interface TableVerifyResponse {
  exists: boolean;
  isAvailable: boolean;
  venue?: VenueData;
  table?: TableData;
}

// Import authentication middleware
import { authenticateFlexible, authenticateOptional } from '../services/auth-service/src/middleware/auth';
const handleDirectTableVerify = async function(req: any, res: any) {
  try {
    const { tableId } = req.params;
    if (!mongoose.Types.ObjectId.isValid(tableId)) {
      Log.warn('Invalid table ID format in verification request', { 
        tableId, 
        correlationId: req.correlationId 
      });
      return res.status(400).json({ error: 'Invalid table ID format' });
    }

    // Initialize with properly typed response
    const responsePayload: TableVerifyResponse = {
      exists: false,
      isAvailable: false
    };

    const tableDoc = await Table.findById(tableId).populate('venueId').exec();

    if (!tableDoc) {
      Log.info('Table verification: table not found', { 
        tableId, 
        correlationId: req.correlationId 
      });
      return res.status(200).json(responsePayload);
    }

    responsePayload.exists = true;
    responsePayload.isAvailable = (tableDoc as any).isActive;
    
    // Set table data with proper typing
    responsePayload.table = {
      _id: (tableDoc as any)._id.toString(),
      number: (tableDoc as any).number,
      capacity: (tableDoc as any).capacity,
      isOccupied: (tableDoc as any).isOccupied,
      isActive: (tableDoc as any).isActive
    };

    // Set venue data if available
    if ((tableDoc as any).venueId) {
      const venue = (tableDoc as any).venueId;
      responsePayload.venue = {
        _id: venue._id.toString(),
        name: venue.name,
        description: venue.description || '',
        restaurantId: venue.restaurantId
      };
    }
    
    Log.info('Table verification successful', { 
      tableId, 
      exists: responsePayload.exists,
      isAvailable: responsePayload.isAvailable,
      correlationId: req.correlationId 
    });
    
    return res.status(200).json(responsePayload);
  } catch (error) {
    Log.error('Error in direct-verify-table endpoint', { 
      tableId: req.params.tableId,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      correlationId: req.correlationId
    });
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return res.status(500).json({ error: `Error verifying table: ${errorMessage}` });
  }
};

// Apply optional authentication middleware to the direct table verification endpoint
app.get('/api/tables/:tableId/verify', authenticateOptional, handleDirectTableVerify);

// Test endpoints for Sentry error monitoring
app.get('/api/test/sentry-error', (req, res) => {
  Log.info('Sentry error test endpoint called', { correlationId: (req as any).correlationId });
  throw new Error('This is a test error for Sentry monitoring!');
});

app.get('/api/test/sentry-async-error', async (req, res) => {
  Log.info('Sentry async error test endpoint called', { correlationId: (req as any).correlationId });
  try {
    // Simulate an async operation that fails
    await new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(new Error('This is a test async error for Sentry monitoring!'));
      }, 100);
    });
  } catch (error) {
    // Re-throw to let Sentry catch it
    throw error;
  }
});

app.get('/api/test/sentry-custom-error', (req, res) => {
  Log.info('Sentry custom error test endpoint called', { correlationId: (req as any).correlationId });
  
  // Add some custom context to the error
  Sentry.setUser({
    id: 'test-user-123',
    email: 'test@inseat.com',
    username: 'test-user'
  });
  
  Sentry.setTag('test-type', 'custom-error');
  Sentry.setContext('test-context', {
    endpoint: '/api/test/sentry-custom-error',
    timestamp: new Date().toISOString(),
    userAgent: req.get('User-Agent')
  });
  
  const customError = new Error('Custom test error with context and tags!');
  customError.name = 'TestCustomError';
  throw customError;
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', service: 'inseat-backend' });
});

// Swagger Setup
const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'INSEAT API Documentation',
      version: '1.0.0',
      description: 'Documentation for the INSEAT API',
    },
    servers: [
      {
        url: `http://localhost:${process.env.PORT || 3001}`,
        description: 'Development server',
      },
    ],
  },
  apis: ['./src/routes/*.ts', './src/services/auth-service/src/routes/*.ts', './services/order-service/src/routes/*.ts'],
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Enhanced error handling middleware
app.use((err: any, req: any, res: any, next: any) => {
  Log.error('Application error occurred', {
    error: err.message || 'Unknown error',
    statusCode: err.statusCode || err.status || 500,
    stack: err.stack,
    correlationId: req.correlationId,
    method: req.method,
    url: req.url,
    needsRefresh: err.needsRefresh
  });
  
  // Check for status code on error object
  const statusCode = err.statusCode || err.status || 500;
  const message = err.message || 'Internal Server Error';
  
  // Special handling for authentication errors
  const responseBody: any = {
    success: false,
    message: message
  };
  
  // Add needsRefresh flag if present
  if (err.needsRefresh) {
    responseBody.needsRefresh = true;
  }
  
  // Include validation details if this is a validation error
  if (err.details && err.code === 'VALIDATION_ERROR') {
    responseBody.validationErrors = err.details.errors;
    Log.error('Validation error details', { 
      validationErrors: err.details.errors,
      correlationId: req.correlationId
    });
  }
  
  // In development, include more error details
  if (process.env.NODE_ENV !== 'production') {
    responseBody.error = err.stack;
    
    // Log additional error details in development
    Log.debug('Development error details', {
      statusCode,
      message,
      stack: err.stack,
      details: err.details,
      correlationId: req.correlationId
    });
  }
  
  res.status(statusCode).json(responseBody);
});

// Graceful shutdown
const gracefulShutdown = async () => {
  Log.info('Graceful shutdown initiated');
  
  // Stop LiveOrderMonitor
  // LiveOrderMonitor.getInstance().stop();
  
  // Close Socket.IO connections
  await closeSocketIO();
  Log.info('Socket.IO connections closed');
  
  // Shutdown order service
  await shutdownOrderService();
  Log.info('Order service shutdown complete');
  
  // Close server
  server.close(() => {
    Log.info('HTTP server closed');
    // Close MongoDB connection
    mongoose.connection.close().then(() => {
      Log.info('MongoDB connection closed. Exiting process.');
      process.exit(0);
    });
  });
  
  // Force close if it takes too long
  setTimeout(() => {
    Log.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
};

// Listen for termination signals
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

// Add this at the end of src/app.ts
Log.info('Registered routes summary');
app._router.stack.forEach(function(r){
  if (r.route && r.route.path){
    Log.debug('Route registered', { 
      methods: Object.keys(r.route.methods), 
      path: r.route.path 
    });
  }
});
// Force restart
